# SimpleLang Compiler

A complete compiler implementation for SimpleLang, a statically-typed programming language with C-like syntax.

## Author
Soutrik Mukherjee

## Overview
SimpleLang is an educational programming language that demonstrates compiler construction principles. The compiler includes:
- Lexical analyzer (Lexer)
- Syntax analyzer (Parser)
- Semantic analyzer
- Code generator
- Virtual machine for execution

## Language Features
- **Data Types**: int, float, string, bool, void
- **Control Flow**: if-else, while loops, for loops
- **Functions**: Function declarations with parameters and return values
- **Operators**: Arithmetic (+, -, *, /, %), Comparison (==, !=, <, >, <=, >=), Logical (&&, ||, !)
- **Comments**: Single-line (//) and multi-line (/* */)

## Requirements
- Python 3.6 or higher
- No external dependencies required

## Files Included
1. **main.py** - Complete implementation of the compiler with all components
2. **test_input.txt** - Sample test program demonstrating language features
3. **README.md** - Detailed instructions on how to compile and run the code
4. **output_result.txt (optional)** - Shows the complete output when running the test program
5. **run_demo.sh (Bonus Demo Script)** - Bash script that demonstrates multiple examples 

## How to Compile and Run

### Basic Usage

1. **Run with the test file:**
   ```bash
   python3 simplelang_compiler.py test_input.txt
   ```

2. **Run with your own source file:**
   ```bash
   python3 simplelang_compiler.py your_program.sl
   ```

3. **Run with built-in example:**
   ```bash
   python3 simplelang_compiler.py
   ```

### Example Commands

```bash
# Make the compiler executable (optional)
chmod +x simplelang_compiler.py

# Run the test program
python3 simplelang_compiler.py test_input.txt

# Run with a custom program
echo 'int main() { return 42; }' > simple.sl
python3 simplelang_compiler.py simple.sl
```

## Output Explanation

When you run the compiler, it will display:

1. **Lexical Analysis**: Number of tokens generated
2. **Syntax Analysis**: AST generation status
3. **Semantic Analysis**: Type checking results and any errors
4. **Code Generation**: Number of bytecode instructions generated
5. **Bytecode**: The generated bytecode instructions
6. **Execution**: Final result returned by the program

### Sample Output

```
=== Lexical Analysis ===
Generated 89 tokens

=== Syntax Analysis ===
AST generated successfully

=== Semantic Analysis ===
No semantic errors found

=== Code Generation ===
Generated 45 instructions

=== Bytecode ===
   0: JMP skip_func_0
   1: LABEL factorial
   2: LOAD 0
   3: PUSH 1
   4: LE
   5: JZ else_0
   ...

=== Execution ===
Program returned: 225
```

## Language Grammar

SimpleLang follows a context-free grammar with the following key productions:

```
<program> ::= <statement-list>
<statement> ::= <declaration> | <assignment> | <if-statement> | 
                <while-statement> | <for-statement> | <function-declaration> |
                <function-call> | <return-statement> | <block>
<expression> ::= <term> | <expression> <additive-operator> <term>
<term> ::= <factor> | <term> <multiplicative-operator> <factor>
```

## Example Programs

### 1. Hello World (Simple Return)
```c
int main() {
    return 42;
}
```

### 2. Factorial Function
```c
int factorial(int n) {
    if (n <= 1) {
        return 1;
    } else {
        return n * factorial(n - 1);
    }
}

int main() {
    return factorial(5);  // Returns 120
}
```

### 3. Loop Example
```c
int main() {
    int sum = 0;
    for (int i = 1; i <= 10; i = i + 1) {
        sum = sum + i;
    }
    return sum;  // Returns 55
}
```

## Compilation Process

1. **Lexical Analysis**: Converts source code into tokens
2. **Syntax Analysis**: Builds an Abstract Syntax Tree (AST)
3. **Semantic Analysis**: Performs type checking and symbol resolution
4. **Code Generation**: Converts AST to stack-based bytecode
5. **Execution**: Virtual machine executes the bytecode

## Bytecode Instructions

The compiler generates the following bytecode instructions:
- **Stack Operations**: PUSH, POP, DUP
- **Memory Operations**: LOAD, STORE
- **Arithmetic**: ADD, SUB, MUL, DIV, MOD, NEG
- **Comparison**: EQ, NEQ, LT, GT, LE, GE
- **Logical**: NOT
- **Control Flow**: JMP, JZ (jump if zero), JNZ (jump if not zero)
- **Functions**: CALL, RET
- **Other**: LABEL, HALT

## Error Handling

The compiler provides detailed error messages for:
- Lexical errors (invalid characters, unterminated strings)
- Syntax errors (unexpected tokens, missing semicolons)
- Semantic errors (type mismatches, undefined variables, incorrect function calls)

## Testing

Run the included test file to see all language features in action:
```bash
python3 simplelang_compiler.py test_input.txt
```

The test program demonstrates:
- Function declarations and calls
- Recursive functions (factorial and fibonacci)
- Arithmetic operations
- Control flow (if-else, while, for)
- Nested function calls

## Limitations

- No support for arrays or pointers
- No string operations beyond literals
- Limited type conversions (only int to float)
- No input/output operations
- No external libraries or modules

## Future Enhancements

Planned features for future versions:
- Arrays and dynamic memory
- String manipulation
- User-defined types (structs)
- Module system
- Standard library
- Optimization passes

## Troubleshooting

1. **Python Version Error**: Ensure you're using Python 3.6+
   ```bash
   python3 --version
   ```

2. **File Not Found**: Check that the input file exists
   ```bash
   ls test_input.txt
   ```

3. **Syntax Errors**: The compiler will show line and column numbers for errors

## License

This is an educational project created for demonstrating compiler construction principles, done by Soutrik Mukherjee.